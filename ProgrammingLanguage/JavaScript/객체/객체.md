```table-of-contents
style: nestedList # TOC style (nestedList|inlineFirstLevel)
maxLevel: 0 # Include headings up to the speficied level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
---
# 1. 객체

- Key 와 Value 로 구성된 속성의 집합
- 리터럴 `{}` 방식으로 객체를 생성 가능

## 1-1 프로퍼티

```
const 객체이름(user) = {
	key : value,
	name : james
	...
	(property),
}
```

* 마지막 프로퍼티 끝에 쉼표 올 수 있음
* 프로퍼티 키 이름엔 제약사항이 없음(for,let,return..)
  (문자/심볼형이 아닌 키 값은 문자열로 자동 형 변환)

* `__proto__`는 특별 프로퍼티 이름으로 예약어 

### 1-1-1 객체 밖에서 프로퍼티에 접근

- Value 재할당
	- 해당하는 Key 가 없을 경우 동적으로 속성 추가
	- 객체의 주소 값은 그대로이며 주소 같이 참조하는 원본 객체 데이터에 얕은 복사	
```
person.name = "kim" 
```

- Value 삭제
	- delete 키워드로 삭제 가능
```
delete person.name;
```

## 1-1-2 계산된 프로퍼티(computed property) 

- 프로퍼티 이름을 동적으로 받음
```
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
let bag = {
	[fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받음
};
alert( bag.apple ); // fruit에 "apple"이 할당되면 5 출력
```


### 1-1-3 단축 프로퍼티 

- 변수를 사용해 프로퍼티를 만듦

```
function makeUser(name, age) {
return {
		name: name,
	age,
};
}

let user = makeUser("John", 30);
alert(user.name); // John
```

### 1-1-4 프로퍼티 존재 확인 방법 

- for .. in 사용

### 1-1-5 프로퍼티 정렬 방식

- 정수 프로퍼티는 자동 정렬(변형 없이 정수에서 문자열 변환이 가능한 프로퍼티)
	- "49" 는 정수프로퍼티
	- "+49" , "1.2" 등은 아님
- 그 외 객체 추가한 순서대로 정렬

### 1-1-6 프로퍼티 접근법

- 대괄호 `[]`
	- 문자열, 배열, 함수에 모두 접근 가능
```
const person = {
	name : {
		lastName = "Hong",
		...
	},
	printHello:function(){
		...
	}
	...
};
console.log(person["name"]["lastName"]);
console.log(person["printhello"]());	
```

- 마침표 `.`
	* 객체 key에 공백이 있을 경우 접근 불가
```
console.log(peson."name");
```

* 접근법의 차이
	* 대괄호 표기법은 변수를 프로퍼티 키로 사용 가능 (점 표기법은 불가능)
```
let v = "name";
user.v // undefined
user[v] // james
```

## 1-2 메서드

- 메서드 : 객체 내에서 함수가 속성의 값일 때 함수를 지칭
- 객체 내 메서드 선언시 function 생략 가능
```
user = {
	sayHi() { // "sayHi: function()"과 동일.
			alert("Hello");
	}
};
```

## 1-3 this 

- `this` 키워드를 사용하여 객체에 접근가능(객체 내 메서드에서 객체를 호출 가능)
* 모든 함수에 사용가능, this는 런타임에 결정( . 앞의 객체를 참조 )
* 객체 없이도 호출가능 ( 엄격모드일 경우 this == undefined )
  (엄격 모드가 아닐경우 this가 전역 객체(window)를 참조)
* 화살표 함수 내에서 this는 외부 컨텍스트를 참조 ( 자신의 this 없음 )
* this 값은 호출시점에 결정 (`.` 앞의 객체를 참조, `발화점`)

```
function makeUser() {
	return {
			name: "John",
			ref: this
	};
};
let user = makeUser();

// this 호출시 undefined 로 결정
// this가 함수로 호출됨
// ref: this 는 현재 this의 값(undefined)
alert( user.ref.name ); // Error: Cannot read property 'name' of undefined
```

```
function makeUser() {
	return {
		name: "John",
			ref() {
			return this;
			}
	};
};
let user = makeUser();

// ref() 메서드 this반환( makeUser() ), user.ref()는 user.this와 같다.
alert( user.ref().name ); // John
```

## 1-4 메서드 호출 체이닝 

- 메소드들의 반환값을 `this`로 설정하면 `.`으로 체인을 이룰 수 있음 

```
let ladder = {
	step: 0,
	up() {
		this.step++;
		return this;
	},
	down() {
		this.step--;
		return this;
	},
	showStep() {
			alert( this.step );
			return this;
	}
}

ladder.up().up().down().up().down().showStep(); // 1
```

### 1-4-1 옵셔널 체이닝 `?.`  

- 프로퍼티가 없는 중첩 객체를 안전하게 접근
>객체에 존재하지 않는 프로퍼티에 접근시 `&&`를 사용하였으나 코드가 길어짐
>`?.` 앞의 평가 대상이 `undefined/null` 일 경우 평가 종료, `undefined` 반환
>선언이 완료된 변수 대상으로만 동작 

  - 다양한 방식으로 조합가능
	- 메서드와 조합시 `?.()`
	- 프로퍼티와 조합시 `?.[]`
	- `delete`와 조합가능

* 옵셔널 체이닝은 연산자가 아닌 문법 구조체
> 옵셔널 체이닝은 할당 연산자 왼쪽에 올 수 없음

* 단락 평가 예시
```
let user = null;
let x = 0;
user?.sayhi(x++); // user === null 이므로 오른쪽 동작 X
alert(x); // 0, x 증가 안함 
````

## 1-5 객체 복사

- 참조에 의한 객체 복사
- 객체에서 `"==", "==="` 는 동일하게 작동

### 1-5-1 객체 복사방법 

- 1. 얕은복사 
	- `Object.assign(dest, [src1, src2, src3...])` 
> 목표객체(dest)에 src1,... 의 프로퍼티 모두를 dest 에 복사후 dest 반환
> 동일한 프로퍼티가 있을 경우 기존 값이 덮어씌워짐

- 2. 깊은복사
	- 라이브러리 `lodash` 의 메서드 `_.cloneDeep(obj)`` 사용 
	* Deepcopy 표준 알고리즘 =  Structured cloning algorithm
		- [DeepCopy Algorithm](https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data)


## 1-6 표준 내장 객체(Standard Built-in Object)

- String 
	- `length` : 문자열 길이 반환
	- `includes()` : 문자열이 대상 문자열에 포함시 true 아니면 false
	- `replace()` : 문자열과 일치하는 한 부분을 찾아서 다른 데이터로 변경한 새로운 문자열 반환
	- `replaceAll()` : 일치하는 모든 부분을 찾아서 다른 데이터로 변경한 새로운 문자열 반환
	- `split()` : 매개변수 인자로 구분자를 기준으로 문자열을 분리하여 배열로 반환
	- `toUpperCase()` : 문자열을 대문자로 변경
	- `trim()` : 대상 문자열의 앞,뒤 공백 제거
	- `indexOf()` : 대상 문자열과 일치하는 첫 번째 문자의 인덱스 반환 못 찾으면 -1 반환
	
- Array
	- `length`
	- `push()` : 배열 맨 뒤에 데이터 추가
	- `pop()` : 배열 맨 뒤 데이터 추출
	- `unshift()` : 배열 맨 앞 데이터 추가
	- `shift()` : 배열 맨 앞 데이터 추출
	- `sort() / reverse()` : 배열 정렬
	- `forEach()` : 배열의 요소를 하나씩 순회하며 callback 함수 호출
	- `filter()` : 배열의 요소를 하나씩 순회하며 콜백 함수 호출
		- true 반환하는 요소만 추출
		- 추출한 요소로 새로운 배열을 만들어 반환
	- `find()` : 주어진 판별 함수를 만족하는 배열의 첫 번째 값 반환
	- `findIndex()` : 주어진 판별 함수를 만족하는 배열의 첫 번째 인덱스 반환
	- `includes()`
	- `join()` : 배열의 모든 요소를 주어진 구분자로 합쳐 문자열로 반환

- Date
	* 인스턴스 생성 필수 : `const date = new date();`
	- `get/setFullyear()` : 4자리 년도
	- `get/setMonth()` : 월(0 ~ 11)
	- `get/setDate()` : 일(1 ~ 31)
	- `getDay()` : 요일(0 ~ 6)
	- `get/setTime()` : 1970년 1월 1일 12:00 이후의 시간을 밀리초 단위로 표시
	- `get/setHours()` : 시(0 ~ 23)
	- `get/setMinutes()` : 분(0 ~ 59)
	- `get/setSeconds()` : 초(0 ~ 59)
	- `get/setMilliseconds()` : 밀리초(0 ~ 999) 

- Math
	- `floor()` : 내림
	- `ceil()` : 올림
	- `round()` : 반올림
	- `random()` : 0 이상 1 미만 난수 반환		

---
>[[JavaScript]]
#object #method #property